# bool 
* 只在c++中使用
* 只占用一个字节
* if(bool)/if(!bool) ，不要写作if(bool == true)/if(bool == false)

# const
* #define PI 3.14 / const double PI = 3.14;  
    `宏定义没有类型， const定义有类型`
* const修饰变量， 被修饰的的变量必须在定义时赋值， 在编译时无法再次赋值  
  
* 编译器会在编译时自动优化，将所有被初始化的const变量替换为初始化值  
    
## const指针
* const TYPE* / TYPE const* 指针变量指向的内容无法被修改, 指针变量可以被修改
  
* TYPE* const 指针变量指向的内容可以被修改， 指针变量的值无法被修改
  
* conts TYPE* const / 指针变量指向的内容无法被修改， 指针变量的值无法被修改
  
* 使用const_cast<TYPE*>() 去除const修饰符
```c++
    const int n = 5;
    int* p = const_cast<int*>(&n);
```
# 默认参数

1. 函数默认参数
```c++
    void foo(int a, int b = 5){}; // b为默认参数  
```
* 默认可以写在函数声明或定义处，但**只能出现在一个地方**，一般写在**声名处**

* 一个参数有默认参数时， 其右边的所有参数都必须有默认参数
```c++
    void foo(int a, int b = 5, double c = 3.0){}; // 正确
    void foo(int a, int b = 5, double c){}; // 错误
```

* 有默认参数的函数在调用时可以不输入默认的参数，也可以输入
```c++
void foo(int a, int b = 5, int c = 3.0)
{
    std::cout << "a=" << a << std::endl;
    std::cout << "b=" << b << std::endl;
    std::cout << "c=" << c << std::endl;
}

int main()
{
    int m = 12;
    int n = 7;
    double dou = 1.0;
    foo(m, n);  // 输出 a=12 b=7 c=3
    foo(m, dou); // 输出 a=12 b=1 c=3, dou被当做第二个参数强转为int输入

    return 0;
}
```

# 内联函数 - inline

1. 内联函数是对编译器的建议， 编译器会自己决定是否内联

2. 内联函数必须写在头文件里


# 引用 - Reference

1. 通过函数改变输入参数的值
    * 通过指针来修改会存在风险（使用不规范）

2. 定义方法
* 引用**必须**在定义时初始化
* 不能用常量给引用初始化
```c++ 
    int n = 5;     
    int &refN;             // 错误，引用必须在定义时初始化
    int &refN = 5;         // 错误，不能用常量初始化引用
    const int &m = 12;     // 正确，可以用常量对引用初始化
    int &refN = n;         // 正确，正常引用
    refN = 6;              // 此时n=6, refN=6, 改变引用能改变原变量的值
    n = 7;                 // 此时n=7, refN=7, 改变原变量的值也能同时改变引用的值
```
* 引用一旦被初始化，就无法再修改引用关系
```c++
    int n = 5;
    int m = 7;
    int& refN = n;      // 定义refN为n的引用

    refN = m;           // 这里有两种理解：
                        // 1.重新将refN定义为m的引用
                        // 2.将m的值赋值给refN和n
                        // 编译无错误，可以执行，结果是n和refN的值变为7
```

3. 使用方法

* 函数形参为引用时，传入参数可以为引用类型或普通类型，函数对传入参数的修改**会**在函数外被保留
* 函数形参为普通类型时，传入参数可以为引用类型或普通类型，函数对传入参数的修改**不会**在函数外被保留
```c++
void foo(int input)
{
    input += 1;
}

void fooRef(int& input)
{
    input += 1;
}

int main()
{
    int n = 1;
    int &refN = n;

    foo(n);         // 形参为int，函数对传入int的修改不会保留
                    // n = 1, refN = 1

    foo(refN);      // 形参为int，函数对传入int&的修改也不会保留
                    // n = 1, refN = 1

    fooRef(n);      // 形参为int&，函数对传入int的修改会保留
                    // n = 2, refN = 2

    fooRef(refN);   // 形参为int&，函数对传入int&的修改会保留
                    // n = 3, refN = 3

    return 0;
}
```

* 使用引用作为函数返回值

* 存在二级指针，不存在二级引用，但可以使用指针的引用来替代二级指针
```c++
int main()
{
    int n = 3;      
    int* p = &n;    // 定义指向int的指针变量p，指向n
    int*& refP = p; // 定义指向int的指针变量的引用，初始化为p
                    // 此时*p == *refP == n = 3;
    return 0;
}
```

* 不能用引用和普通类型来进行重载，例如：
```c++
void fooRef(int input)
{
    input += 1;
}

void fooRef(int& input)
{
    input += 1;
}
// 在编译时会报错，编译器无法区分这种重载
```

4. 引用的本质
* 引用是变量的别名，变量可以是普通变量，也可以是指针变量，也可以是复杂的变量比如类的对象等
* **引用本质是指针常量**，在使用时无法修改

# 作用域

1. 全局作用域 或 命名空间域(namespace)
2. 局部作用域 块作用域(代码块)
3. 类域(class)

## 数据隐藏
1. 在不同作用域可以定义多个名字相同的变量
2. 内部的变量会隐藏外部的变量(从内->外查找同名变量)

## 命名空间
1. 命名空间可以分开定义
2. 命名空间可以嵌套
3. 命名空间可以取别名
```c++
namespace LhyTest
{
    int little_black;
    void foo()
    {
        little_black = 111;     // 这里修改的是LhyTest::内的变量
        ::little_black = 333;   // ::前没有空间名表示使用全局作用域
    }
};
namespace NewLhy = LhyTest; // 此时NewLhy::little_black 等价于 NewLhyTestLhy::little_black
```
### 命名空间的使用
1. (推荐)直接使用`空间名::内容`
2. (不推荐)声明 `using namespace XXX;`, 在后续代码中可以直接使用XXX空间中的全部内容
3. 声明只使用命名空间的部分内容 `using namespace XXX::yy;`

* .c/.cpp -cl.exe(编译) --> .obj --linker.exe(链接) --> exe

# 函数重载
## 重载的条件（函数要素：函数名、函数参数、函数返回值、函数调用规定）
1. 函数名必须相同
2. 函数参数**个数不同，类型不同，顺序不同**可以重载
3. 返回值和**调用约定(?)**不考虑为重载（不能通过改变返回值或调用约定来重载）
4. 作用域相同才能够重载（不同作用域下的同名函数其实是不同的函数）

### 调用约定(?)
    待补充

## 函数重载的调用规则
1. 根据函数名找所有重名的函数作为候选函数，若候选函数为0则报错
2. 候选函数数量＞0，从中找可以匹配的函数(完全匹配、可以隐式转换的函数)
    * 匹配个数 == 0 ，报错
    * 匹配个数 > 0 ,  找最佳匹配
3. 最佳匹配个数 == 1 ，则使用该函数； 最佳匹配个数 > 1 ，报二义性错误（即存在歧义）
4. 编译器有一个匹配积分规则，以此判断是否最佳匹配
    * 写重载时尽量避免出现隐式转换匹配

## 函数重载的本质
    名称粉碎(?)

# 面向对象及类
